---
layout: slides
title: Strings and Numbers
---
<section>
	<h1>Strings and Numbers</h1>
	<footer>MTEC2002 - Joe Versoza</footer>
</section>


<section>
<h2>Overview</h2>
<ul>
	<li>The Python interpreter</li>
	<li>Syntax</li>
	<li>Strings</li>
	<li>Numbers</li>
</ul>
</section>


<section>
<h2>The Python interpreter</h2>
<ul>
	<li>Running programs</li>
	<li>Interactive shell</li>
	<li>Some mild introspection</li>
</ul>
<details>
</details>
</section>

<section>
<h2>Running programs</h2>
<ul>
	<li>Use the interpreter followed by the filename of your program</li>
	<li>The extension of the filename can be anything, but .py is the convention</li>
</ul>
{% highlight console %}
walsh:tmp joe$ echo "print 'Hi!'" > hello.py
walsh:tmp joe$ python hello.py 
Hi!
{% endhighlight %}
<details>
<ul>
	<li>Can pass flags... for example --help shows help, -c runs a command</li>
	<li>python -c 'print "hello"'</li>
</ul>
</details>
</section>

<section>
<h2>Interactive shell</h2>
<ul>
	<li>Without the filename, the interactive shell is started</li>
	<li>Executes input line-by-line</li>
</ul>
{% highlight pycon %}
>>> # prompts for an expression or statement
... # prompts that an expression or statement needs more input
{% endhighlight %}
<ul>
	<li>&lt;Enter&gt; after a prompt for more input ends that expression or statement</li>
	<li>Values returned from expressions are printed out</li>
	<li>Instant feedback is great for testing, debugging and experimenting</li>
</ul>
<details>
<pre>
5 + 3
import sys
if True:
	print "I don't believe it!"
if True: # waiting for input shows an error
...
# show what "asdf" vs "" resolves to in if statement
</pre>
</details>
</section>

<section>
<h2>Some mild introspection... and others</h2>
<ul>
	<li>help</li>
	<li>dir</li>
	<li>type</li>
	<li>import</li>
	<li>print</li>
</ul>
<details>
<pre>
help() # no params gives you interactive help.  "quit" or ^D to quit.
keywords, ^D
help([1, 2, 3]), import sys, help(sys) #... by the way, brackets denotes a list!
import sys, dir(sys), dir(""), dir([]) # import brings in a module... (which is just a file with code)
type(sys), type(5), li = [], type(li), dir(li), type(li.append),
 help(li.append), li, li.append('foo'), li
</pre>
</details>
</section>

<section>
<h2>Syntax</h2>
<ul>
	<li>Basic syntax</li>
	<li>Dot notation, functions/methods and attributes</li>
	<li>Expressions and simple assignment</li>
	<li>Space! Object spaces, namespaces</li>
	<li>Assignment / binding?</li>
</ul>
<details>
</details>
</section>

<section>
<h2>Basic syntax</h2>
<ul>
	<li>White space significant</li>
	<li>Colon and indentation signify code blocks</li>
	<li>Each line is a single statement</li>
</ul>
<details>
<ul>
	<li>Leading whitespace is meaningful to the program structure!</li>
	<li>You can use tabs or spaces, but not both.  The convention is to use 4 spaces, though any number is possible as long as it's consistent (demo if with one space, then two).  I use tabs, which is bad.</li>
	<li>blocks, or groups of statements are specified by indentation level.</li>
	<li>lines separate statements, unless you explicitly create a continuation using a backslash, but must indent next (demo).</li>
	<li>or """ quoted string, or an unbalanced brace, bracket, parens (demo).</li>
</ul>
</details>
</section>

<section>
<h2>Dot notation, functions/methods and attributes</h2>
<ul>
	<li>Dots are used for accessing both functions/methods and attributes</li>
	<li>Functions and methods are invoked with parentheses; they're "callables"</li>
	<li>Attributes can be accessed and assigned</li>
</ul>
<details>
<ul>
	<li>You'll see that they're both actually the same... functions/methods are just callable attributes.  use [].append</li>
	<li>Demo callable keyword (foo = 12, def bar(): pass, callable)</li>
</ul>
<pre>
>>> class Foo:
...  def __init__(self):
...   self.bar = 12
</pre>
</details>
</section>


<section>
<h2>Expressions and simple assignment</h2>
<ul>
	<li>Arithmetic operations</li>
	<li>Assignment</li>
	<li>Multiple and consecutive assignment</li>
	<li>Undefined variables</li>
</ul>
<details>
<ul>
	<li>(demo)+ - *  / all work as you'd expect.  whitespace separating tokens is not significant.</li>
	<li>(demo) also % (modulo), 5**2 for exponents, bitwise ops 6&amp;2, 2|4, 8&lt;&lt;1 </li>
	<li>(demo) use = to assign variables</li>
	<li>(demo) a = b = c = 2</li>
	<li>(demo) (a, b, c) = (1, 2, 3) ... these are actually tuples, we'll talk about these later</li>
	<li>(demo) use undefined u + 2 throws NameError</li>
</ul>
</details>
</section>


<section>
<h2>Strings</h2>
<ul>
	<li>String literals delimited with
		<ul>
			<li>'single quotes'</li>
			<li>"double quotes"</li>
			<li>"""triple double quotes</br>
					span lines!"""</li>
		</ul>
	</li>
	<li>Use backslash to escape quotes, doublequotes and other backslashes</li>
	<li>\n is a new line (line feed), \r is a carriage return</li>
	<li>unicode strings are prefixed by u... u"snowman"</li>
</ul>
<details>
<ul>
	<li>(demo) note that you don't have to escape when using mixed quoting</li>
	<li>(demo) same as above... don't have to escape double quotes in triple double quotes  </li>
</ul>
</details>
</section>

<section>
<h2>String formatting / interpolation</h2>
<ul>
	<li>String and unicode objects can be formatted using the % operator
		<ul>
			<li>String interpolation is a way of substituting values into a format string</li>
			<li><em>format</em> % <em>value(s)</em></li>
		</ul>
	</li>
</ul>
{% highlight python %}
>>> a = "milk"
>>> b = "cookies"
>>> s = "I like %s and %s" % (a, b)
>>> s
'I like milk and cookies'
{% endhighlight %}
<details>
</details>
</section>

<section>
<h2>% what?</h2>
<ul>
	<li>Format strings use %<em>character</em> as placeholder for values</li>
	<li>These are called conversion specifiers</li>
	<li>Some available conversion specifiers include:
		<ul>
			<li>%d - integer</li>	
			<li>%f - float</li>	
			<li>%s - string</li>	
			<li>%c - character</li>	
		</ul>
	</li>
</ul>
<details>
<ul>
	<li>An exception will be thrown if the type does not match the type specified in the format</li>
	<li>"%i will throw an exception" % "foo"</li>
	<li>There are more complex conversion specifiers; these are the most common</li>
</ul>
</details>
</section>

<section>
<h2>Common string functions and methods</h2>
<p>String methods and functions can be used on both variables and string literals:</p>
{% highlight python %}
a = "foo"
a.upper()
"foo".upper()
{% endhighlight %}
<p>Common functions and methods:</p>
{% highlight python %}
len("foo") # length of string
re.sub("a.$", "ooooo", "foo bar baz") # regex
"  foo ".strip() # strip surrounding whitespace
"foo".startswith('f') # true if string starts with x
"foo".startswith('f') # true if string starts with x
"foo bar baz".split(' ') # returns list of substrings
{% endhighlight %}
<details>
</details>
</section>

<section>
<h2>Numbers</h2>
<ul>
	<li>int --&gt; 5</li>
	<li>long --&gt; 5.5555555</li>
	<li>float --&gt; 5.55</li>
	<li>complex --&gt; 5 + 5j</li>
	<li>Types widen int --&gt; long --&gt; float --&gt; complex</li>
	<li>Constructors: int(), long(), float(), and complex()</li>
</ul>
<details>
<ul>
	<li>'Regular' numbers get int type, numbers with a decimal point are floats</li>
	<li>(demo) floats and ints using type()</li>
	<li>operands are widened to accommodate wider type when performing operations</li>
	<li>(demo) operations on two integers yield integers 5 / 2</li>
</ul>
</details>
</section>
